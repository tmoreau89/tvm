"""Programming utilities for Ultra-96.

Provides functions to program the Ultra-96 FPGA.
"""
import os
import struct
import numpy as np

def program_ultra96(bitfile_name):
    """The method to download the bitstream onto PL.
    Note
    ----
    The class variables held by the singleton PL will also be updated.
    Returns
    -------
    None
    """
    BS_FPGA_MAN = "/sys/class/fpga_manager/fpga0/firmware"

    if not os.path.exists(BS_FPGA_MAN):
        raise RuntimeError("Could not find programmable device")

    bin_file = os.path.basename(bitfile_name).replace('.bit', '.bin')
    bin_path = '/lib/firmware/' + bin_file
    convert_bit_to_bin(bitfile_name, bin_path)
    with open(BS_FPGA_MAN, 'w') as fd:
        fd.write(bin_file)

def convert_bit_to_bin(bitfile_name, bin_path):
    """The method to convert a .bit file to .bin file.
    A .bit file is generated by Vivado, but .bin files are needed
    by the Zynq Ultrascale FPGA manager driver. Users must specify
    the absolute path to the source .bit file, and the destination
    .bin file and have read/write access to both paths.
    Note
    ----
    Imlemented based on: https://blog.aeste.my/?p=2892
    Returns
    -------
    None
    """
    bit_data = parse_bit_header(bitfile_name)
    bit_buffer = np.frombuffer(bit_data['data'], dtype=np.int32, offset=0)
    bin_buffer = bit_buffer.byteswap()
    bin_buffer.tofile(bin_path, "")

def parse_bit_header(bitfile_name):
    """The method to parse the header of a bitstream.
    The returned dictionary has the following keys:
    "design": str, the Vivado project name that generated the bitstream;
    "version": str, the Vivado tool version that generated the bitstream;
    "part": str, the Xilinx part name that the bitstream targets;
    "date": str, the date the bitstream was compiled on;
    "time": str, the time the bitstream finished compilation;
    "length": int, total length of the bitstream (in bytes);
    "data": binary, binary data in .bit file format
    Returns
    -------
    Dict
        A dictionary containing the header information.
    Note
    ----
    Implemented based on: https://blog.aeste.my/?p=2892
    """
    with open(bitfile_name, 'rb') as bitf:
        finished = False
        offset = 0
        contents = bitf.read()
        bit_dict = {}

        # Strip the (2+n)-byte first field (2-bit length, n-bit data)
        length = struct.unpack('>h', contents[offset:offset + 2])[0]
        offset += 2 + length

        # Strip a two-byte unknown field (usually 1)
        offset += 2

        # Strip the remaining headers. 0x65 signals the bit data field
        while not finished:
            desc = contents[offset]
            offset += 1

            if desc != 0x65:
                length = struct.unpack('>h',
                                       contents[offset:offset + 2])[0]
                offset += 2
                fmt = ">{}s".format(length)
                data = struct.unpack(fmt,
                                     contents[offset:offset + length])[0]
                data = data.decode('ascii')[:-1]
                offset += length

            if desc == 0x61:
                s = data.split(";")
                bit_dict['design'] = s[0]
                bit_dict['version'] = s[2]
            elif desc == 0x62:
                bit_dict['part'] = data
            elif desc == 0x63:
                bit_dict['date'] = data
            elif desc == 0x64:
                bit_dict['time'] = data
            elif desc == 0x65:
                finished = True
                length = struct.unpack('>i',
                                       contents[offset:offset + 4])[0]
                offset += 4
                # Expected length values can be verified in the chip TRM
                bit_dict['length'] = str(length)
                if length + offset != len(contents):
                    raise RuntimeError("Invalid length found")
                bit_dict['data'] = contents[offset:offset + length]
            else:
                raise RuntimeError("Unknown field: {}".format(hex(desc)))
        return bit_dict
